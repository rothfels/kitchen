angular.module 'mock.firebase', []
.value 'Firebase', MockFirebase
.config ($windowProvider) ->
  $windowProvider.Firebase = $windowProvider.MockFirebase
.run -> MockFirebase.override()

window.stub = ->
  out = {}
  out[arg] = sinon.spy() for arg in arguments
  out

window.stubs =
  fbutil:
    type: 'factory'
    value: ->
      ($firebase) -> window.fbutilStub.generate($firebase)
  $firebaseSimpleLogin:
    type: 'factory'
    value: ->
      ($q, $rootScope) -> window.authStub.generate($q, $rootScope)
  $location:
    type: 'value'
    value: -> window.stub('path')
  $state:
    type: 'value'
    value: -> window.stub()

window.provideAllExcept = ($provide, exclusions...) ->
  stubKeys = _.difference(_.keys(window.stubs), exclusions)
  for key in stubKeys
    stub = window.stubs[key]
    $provide[stub.type](key, stub.value())
  null # https://groups.google.com/forum/#!msg/angular/gCGF_B4eQkc/XjkvbgE9iMcJ

window.provideAll = ($provide) -> window.provideAllExcept($provide)

window.requireUser = ($provide) ->
  $provide.value('user', window.authStub.$$user)
  null # https://groups.google.com/forum/#!msg/angular/gCGF_B4eQkc/XjkvbgE9iMcJ

window.stubIndices = ($httpBackend) ->
  $httpBackend.whenGET('data/recipeIndex.json').respond(mockIndices.mockRecipeIndex())
  $httpBackend.whenGET('data/ingredientIndex.json').respond(mockIndices.mockIngredientIndex())

window.flushAll = ($timeout, $httpBackend) ->
  try
    while true
      # Flush until there is nothing left to flush ($timeout throws error).
      # For many tests this is important since there will be sequences of
      # firebase loads / writes, http backend flushes, and promise resolutions.
      window.fbutilStub.flush()
      if $httpBackend?
        $httpBackend.flush()
      $timeout.flush()
  catch error # Ignored.

# Stub for fbutil
class FBUtilStubFactory
  constructor: ->

  $$root: null # Firebase root. All references are created as children of this root. Reset with each generation.
  $$last: null # The last fbutil stub generated. Reset with each generation.
  $$lastRefs: null # A list of Firebase refs generated by getRef (with keep = true). Reset with each generation.
  getRef: (keep, path...) -> # Path may be provided as 'child1/child2/...' or ['child1', 'child2', ...]
    ref = @$$root
    ref = ref.child("#{child}") for child in path

    @$$lastRefs.unshift(ref) if keep # Add to front.
    if @nextRefSetOverride?
      ref.set = @nextRefSetOverride # Override set() method on ref.
      @nextRefSetOverride = null
    ref
  generate: ($firebase) ->
    self = @
    self.$firebase = $firebase
    spyObj =
      syncObject: (path...) -> self.$firebase(self.getRef(true, path...)).$asObject()
      syncArray: (path...) -> self.$firebase(self.getRef(true, path...)).$asArray()
      ref: (path...) -> self.getRef(true, path...)

    # Register spies on each spyObj method.
    sinon.spy(spyObj, method) for own method of spyObj

    @$$root = new MockFirebase('Mock://').child('data')
    @$$last = spyObj
    @$$lastRefs = []

    spyObj
  nextRefSetOverride: null
  flush: -> @$$root.flush()
  init: (data, path...) ->
    ref = @getRef(false, path...)
    ref.set(data) # TODO: should we flush here?

window.FBUtilStubFactory = FBUtilStubFactory
window.fbutilStub = new FBUtilStubFactory()

# Stub for $firebaseSimpleLogin
class AuthStubFactory
  constructor: ->

  events:
    $login: '$firebaseSimpleLogin:login'
    $logout: '$firebaseSimpleLogin:logout'
    error: '$firebaseSimpleLogin:error'
    refresh: '$firebaseSimpleLogin:refresh' # For testing only.

  $$last: null # The last $firebaseSimpleLogin generated. Reset with each generation.
  $$lastContext: $q: null, $rootScope: null # Injected dependencies for last generation.
  $$user: uid: '0' # Current user context. $createUser will increment uid by 1; it can also be set.
  $$isAuth: false # Flag controlling method stub return values, primarily for $getCurrentUser.
  generate: ($q, $rootScope, auth = true) ->
    @$$isAuth = auth
    self = @
    -> # $firebaseSimpleLogin will get invoked as a function (pass an fb-URL base)
      spyObj =
        $login: ->
        $logout: ->
        $createUser: ->
        $changePassword: ->
        $removeUser: ->
        $getCurrentUser: ->
        $sendPasswordResetEmail: ->

      self.$$last = spyObj
      self.$$lastContext = $q: $q, $rootScope: $rootScope
      self.stubAll()
      spyObj

  stubAll: ->
    [$rootScope, $q] = [@$$lastContext.$rootScope, @$$lastContext.$q]

    self = @
    stubFn = (method) -> switch method
      when '$login' then ->
        self.$$isAuth = true
        $rootScope.$broadcast(self.events.$login)
        $q.when(self.$$user)
      when '$logout' then ->
        self.$$isAuth = false
        $rootScope.$broadcast(self.events.$logout)
        $q.when(null)
      when '$getCurrentUser' then ->
        if self.$$isAuth then $q.when(self.$$user) else $q.when(null)
      when '$createUser' then ->
        self.$$isAuth = true
        self.$$user.uid = "#{parseInt(self.$$user.uid) + 1}" # Auto-increment.
        $q.when(null)
      when '$changePassword' then ->
        return $q.when(null) if self.$$isAuth # Success.
        $rootScope.$broadcast(self.events.error)
        $q.reject(authRequired: true)
      when '$sendPasswordResetEmail' then ->
        return $q.when(null) if self.$$isAuth # Success.
        $rootScope.$broadcast(self.events.error)
        $q.reject(authRequired: true)
      when '$removeUser' then -> $q.when(null) # Success.

    @stub(method, stubFn(method), false) for own method of @$$last
  stub: (method, fn, unwrap = true) ->
    @$$last[method].restore() if unwrap # Sinon stubs cannot be re-stubbed unless the original method is first restored.
    sinon.stub(@$$last, method, fn)
  error: (method) ->
    [$rootScope, $q] = [@$$lastContext.$rootScope, @$$lastContext.$q]

    event = @events.error
    errorStub = ->
      $rootScope.$broadcast(event)
      $q.reject("#{method} err")

    @stub(method, errorStub, true)

window.AuthStubFactory = AuthStubFactory
window.authStub = new AuthStubFactory()
